<!doctype html>


<html lang="en">


<head>


  <meta charset="utf-8" />


  <title>Orbit HUD â€” CRT Green (Adjusted Sizes & Layers)</title>


  <meta name="viewport" content="width=device-width,initial-scale=1" />





  <!-- React + Babel -->


  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>


  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>


  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>





  <!-- CRT green terminal font -->


  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">





  <style>


    :root {


      --crt-green: #5fff85;


      --crt-dim: #2a4;


      --bg: #000000;


    }


    html, body { margin: 0; height: 100%; background: var(--bg); }


    body { color: var(--crt-green); font-family: 'VT323', ui-monospace, monospace; }





    .crt {


      position: relative;


      min-height: 100vh;


      display: grid;


      place-items: center;


      background: var(--bg);


      overflow: hidden;


    }


    .crt::before {


      content: "";


      position: absolute; inset: 0;


      background: repeating-linear-gradient(


        to bottom,


        rgba(95,255,133,0.06) 0px,


        rgba(95,255,133,0.06) 2px,


        rgba(0,0,0,0) 3px,


        rgba(0,0,0,0) 4px


      );


      pointer-events: none;


      mix-blend-mode: screen;


      opacity: 0.45;


    }


    .crt::after {


      content: "";


      position: absolute; inset: 0;


      background:


        radial-gradient(circle at 50% 50%, rgba(0,0,0,0) 60%, rgba(0,0,0,0.35) 85%),


        linear-gradient(to bottom, rgba(255,255,255,0.03), rgba(0,0,0,0) 40%, rgba(255,255,255,0.02) 60%, rgba(0,0,0,0.1));


      pointer-events: none;


      mix-blend-mode: multiply;


    }


    .flicker {


      animation: flicker 2.5s infinite steps(60);


      text-shadow: 0 0 6px rgba(95,255,133,0.6), 0 0 24px rgba(95,255,133,0.25);


    }


    @keyframes flicker {


      0%, 19%, 21%, 23%, 80%, 100% { opacity: 1; }


      20%, 22% { opacity: 0.95; }


      81% { opacity: 0.98; }


    }





    /* Two-column layout (text left, viewport right) */


    .wrap {


      width: 100%;


      max-width: 1400px;


      display: flex;


      gap: 16px;


      align-items: flex-start;


      padding: 14px;


    }





    /* Panel width reduced by 25% (520 -> 390) */


    .panel {


      flex: 0 0 390px;


      border: 1px solid var(--crt-dim);


      background: rgba(0,0,0,0.75);


      padding: 12px 16px;


    }


    .title { font-size: 28px; margin-bottom: 10px; }


    .row { font-size: 22px; display: flex; gap: 6px; margin: 6px 0; }


    .label { opacity: 0.85; min-width: 170px; }


    .value { font-weight: 700; }


    ul.layers { list-style:none; padding:0; margin: 8px 0 0 0; }


    ul.layers li { display:flex; justify-content:space-between; padding: 3px 0; font-size: 20px; }





    /* Viewport size increased by 25% (562 -> 703) */


    .viewport {


      width: 703px;


      height: 703px;


      border: 1px solid var(--crt-dim);


      background: #000;


      box-shadow: 0 0 20px rgba(95,255,133,0.2) inset;


    }





    #errbar {


      position: fixed; top: 0; left: 0; right: 0;


      background: #083; color: #caffda; padding: 6px 10px;


      display:none; z-index: 9999; border-bottom: 1px solid var(--crt-dim);


      font-family: 'VT323', ui-monospace, monospace;


    }


  </style>


</head>


<body>


  <div id="errbar"></div>


  <div id="root" class="crt"></div>





  <script>


    const errbar = document.getElementById('errbar');


    window.addEventListener('error', (e) => {


      errbar.style.display = 'block';


      errbar.textContent = 'Runtime error: ' + (e.message || e.error);


      console.error(e.error || e.message, e);


    });


    window.addEventListener('unhandledrejection', (e) => {


      errbar.style.display = 'block';


      errbar.textContent = 'Unhandled promise rejection: ' + (e.reason && e.reason.message ? e.reason.message : e.reason);


      console.error(e.reason);


    });


  </script>





  <script type="text/babel" data-presets="react">


    const { useEffect, useMemo, useRef, useState } = React;





    // ======== Constants adjusted per request ========


    const WEBDIS_BASE = "http://192.168.30.114:7379";


    const CORE_R = 38;                   // Crushdepth/core radius slightly reduced (from 40)


    const RED_ZONE_R = Math.round(60 * 1.05); // Increase Red Zone height by 5% -> 63


    const PHASE_KEYS = ["Phase1", "Phase2", "Phase3", "Phase4"];


    const PHASE_MAP  = { Phase1: 490, Phase2: 365, Phase3: 244, Phase4: 182 };





    function isTruthy(v) {


      if (v == null) return false;


      const s = String(v).trim().toLowerCase();


      return s === "true" || s === "1" || s === "yes" || s === "on";


    }





    async function webdisMget(keys) {


      try {


        const res = await fetch(`${WEBDIS_BASE}/MGET/${keys.map(encodeURIComponent).join("/")}.json`, { cache: "no-store" });


        if (!res.ok) return [];


        const data = await res.json();


        const g = data?.MGET;


        if (Array.isArray(g) && g.length === keys.length) return g.map(v => (v == null ? null : String(v)));


        if (Array.isArray(g)) return g.map(o => (o && typeof o === 'object' && 'value' in o) ? String(o.value) : null);


        return [];


      } catch { return []; }


    }





    async function webdisGet(key) {


      try {


        const res = await fetch(`${WEBDIS_BASE}/GET/${encodeURIComponent(key)}.json`, { cache: "no-store" });


        if (!res.ok) return null;


        const data = await res.json();


        const g = data?.GET;


        if (Array.isArray(g) && g.length) return String(g[0]);


        if (g && typeof g === 'object' && 'value' in g) return String(g.value);


      } catch {}


      return null;


    }





    async function webdisSet(key, value) {


      try { await fetch(`${WEBDIS_BASE}/SET/${encodeURIComponent(key)}/${encodeURIComponent(value)}.json`, { cache: "no-store" }); } catch {}


    }





    function atmosphericDensity(r) {


      const h = Math.max(0, r - CORE_R);


      if (h > 100) return 0.0001 * Math.exp(-(h - 100) / 50);


      if (h > 60)  return 0.001  * Math.exp(-(h - 60) / 20);


      return 0.01 * Math.exp(-(h - (CORE_R - CORE_R)) / 5); // same shape, base at CORE_R


    }





    function stepOrbit(state, dt, velocityBoost) {


      const rho = atmosphericDensity(state.r);


      const dragAccel = 0.5 * state.Cd * (state.A / state.m) * rho * state.v * state.v * velocityBoost;


      const gravityAccel = state.mu / (state.r * state.r);


      const inwardAccel = dragAccel + gravityAccel;





      state.v += (gravityAccel - dragAccel) * dt;


      if (state.v > 10) state.v = 10;


      if (state.v < 0.1) state.v = 0.1;





      state.r -= inwardAccel * dt * state.v * 0.5;


      if (state.r < CORE_R) state.r = CORE_R;





      state.theta += (state.v / state.r) * dt;


      return state;


    }





    function App() {


      // physics state (real seconds)


      const [orbit, setOrbit] = useState({ r:145, v:1, theta:0, mu:1, Cd:2.2, A:1, m:1 });


      const [fallFactor, setFallFactor] = useState(PHASE_MAP.Phase4);


      const sentFlags = useRef({});





      // HUD constants


      const shipBaseX = 250;


      const shipBaseY = 100;





      // layers & boundaries (Red Zone up 5%, Crushdepth/core to CORE_R)


      const layers = useMemo(() => ([


        { name:"Cloud Deck",    key:"CloudDeck",     r:140,      color:"#4cff9a" },


        { name:"Stratosheath",  key:"Stratosheath",  r:100,      color:"#55ff88" },


        { name:"Red Zone",      key:"RedZone",       r:RED_ZONE_R, color:"#66ff77" },


      ]), []);


      const boundaries = useMemo(() => ([ ...layers, { name:"Crushdepth", key:"Crushdepth", r:CORE_R } ]), [layers]);





      // Poll phases (highest mapped factor among truthy)


      useEffect(() => {


        let stop = false;


        async function poll() {


          try {


            let vals = await webdisMget(PHASE_KEYS);


            if (!vals.length) { // fallback to GETs


              vals = await Promise.all(PHASE_KEYS.map(k => webdisGet(k)));


            }


            const active = PHASE_KEYS.filter((k,i)=>isTruthy(vals[i]));


            const chosen = active.length


              ? active.reduce((acc,k)=> (PHASE_MAP[k] > PHASE_MAP[acc] ? k : acc), active[0])


              : "Phase4";


            setFallFactor(PHASE_MAP[chosen]);


          } catch {}


          if (!stop) setTimeout(poll, 1000);


        }


        poll();


        return ()=>{stop=true};


      }, []);





      // Real-time integration (true seconds)


      useEffect(() => {


        let raf; let last;


        function frame(ts){


          if(!last) last=ts;


          const dt=(ts-last)/1000; last=ts;


          setOrbit(p=>stepOrbit({...p,mu:fallFactor},dt,fallFactor));


          raf=requestAnimationFrame(frame);


        }


        raf=requestAnimationFrame(frame);


        return ()=>cancelAnimationFrame(raf);


      }, [fallFactor]);





      // Set layer flags to Webdis when crossed


      useEffect(() => {


        boundaries.forEach(b=>{


          if(orbit.r <= b.r && !sentFlags.current[b.key]){


            sentFlags.current[b.key] = true;


            webdisSet(b.key, "true"); // one-shot


          }


        });


      }, [orbit.r, boundaries]);





      // Current layer name


      const currentLayer = useMemo(()=>{


        const found = layers.find(l=>orbit.r > l.r);


        return found ? found.name : layers[layers.length-1].name;


      }, [orbit.r, layers]);





      // Orbital path (6+ orbits ahead), relative to ship HUD frame


      const fullPath = useMemo(() => {


        const pts = [];


        const r0 = orbit.r;


        const th0 = orbit.theta;





        // ship-frame basis vectors (prograde/right, inward/down)


        const shipPos = { x: r0 * Math.cos(th0), y: r0 * Math.sin(th0) };


        const T = { x: -Math.sin(th0), y: Math.cos(th0) };    // prograde


        const In = { x: -Math.cos(th0), y: -Math.sin(th0) };  // toward core





        let s = { ...orbit, mu: fallFactor };


        let lastTheta = s.theta, rotations = 0;


        const desiredRotations = 6;


        let steps = 0, MAX = 200000;





        while (s.r > CORE_R && rotations < desiredRotations && steps++ < MAX) {


          s = stepOrbit({ ...s }, 0.03, fallFactor);


          if (s.theta < lastTheta) rotations++;


          lastTheta = s.theta;





          const p = { x: s.r * Math.cos(s.theta), y: s.r * Math.sin(s.theta) };


          const rel = { x: p.x - shipPos.x, y: p.y - shipPos.y };


          const xh = rel.x * T.x + rel.y * T.y;     // right from ship


          const yh = rel.x * In.x + rel.y * In.y;   // down from ship





          const px = shipBaseX + xh;


          const py = shipBaseY + yh;


          pts.push(`${px},${py}`);


        }


        return `M ${shipBaseX},${shipBaseY} ${pts.map((p) => `L ${p}`).join(" ")}`;


      }, [orbit, fallFactor]);





      // Simple ETA predictions (real seconds) for each boundary


      const layerETAs = useMemo(() => {


        return boundaries.map((b) => {


          if (orbit.r <= b.r) {


            return { ...b, status: "Threshold Reached", eta: null };


          }


          let s = { ...orbit, mu: fallFactor };


          let t = 0, dt = 0.05, steps = 0, MAX = 200000;


          while (s.r > b.r && steps++ < MAX) {


            s = stepOrbit({ ...s }, dt, fallFactor);


            t += dt;


            if (s.r <= CORE_R) break;


          }


          if (steps >= MAX) return { ...b, status: "â€”", eta: null };


          return { ...b, status: "ETA", eta: t };


        });


      }, [boundaries, orbit, fallFactor]);





      // Draw


      const planetCY = shipBaseY + orbit.r;





      // Keep scene 1.25x inside the now larger viewport


      const sceneScale = "translate(250,250) scale(1.25) translate(-250,-250)";





      return (


        <div className="wrap">


          {/* Text panel (left) */}


          <div className="panel flicker">


            <div className="title">ORBITAL STATUS â€” LINK: ACTIVE</div>


            <div className="row"><span className="label">Planet Name:</span><span className="value">Unknown</span></div>


            <div className="row"><span className="label">Planet Type:</span><span className="value">Unexplored Gas Giant.</span></div>


            <div className="row"><span className="label">Current Layer:</span><span className="value">{currentLayer}</span></div>





            <div className="row" style={{ marginTop: 8 }}>


              <span className="label">Layer Crossings:</span>


            </div>


            <ul className="layers">


              {layerETAs.map((b, idx) => (


                <li key={idx}>


                  <span>{b.name}</span>


                  {b.status === "Threshold Reached"


                    ? <span>Threshold Reached</span>


                    : b.status === "â€”"


                      ? <span>â€”</span>


                      : <span>ETA: {b.eta.toFixed(1)}s</span>}


                </li>


              ))}


            </ul>


          </div>





          {/* Viewport (right) */}


          <svg className="viewport" viewBox="0 0 500 500">


            <g transform={sceneScale}>


              {/* Planet & layers (core/crushdepth slightly smaller) */}


              <circle cx="250" cy={planetCY} r={CORE_R} fill="#0c2" />


              {layers.map((l,i)=>(


                <circle key={i} cx="250" cy={planetCY} r={l.r} fill="none" stroke={l.color} strokeWidth="2" strokeOpacity="0.35"/>


              ))}


              {/* Spiral path */}


              <path d={fullPath} fill="none" stroke="#5fff85" strokeWidth="1.5" strokeDasharray="4,3" strokeOpacity="0.8" />


              {/* Ship sprite (no rotation changes) */}


              <image href="ship.png" x="238" y="88" width="24" height="24" />


            </g>


          </svg>


        </div>


      );


    }





    const root = ReactDOM.createRoot(document.getElementById('root'));


    root.render(<App />);


  </script>


</body>


</html>