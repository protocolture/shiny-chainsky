<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Orbit HUD — Minimal Readout</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    html, body { margin: 0; height: 100%; background: #000; color:#fff; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .panel { max-width: 640px; margin: 12px auto; padding: 10px 12px; background:#000; }
    .title { font-size: 18px; margin-bottom: 6px; opacity: 0.95; }
    .row { margin: 4px 0; }
    .label { opacity: 0.85; }
    .value { font-weight: 700; }
    ul.layers { list-style:none; padding:0; margin: 6px 0 0 0; }
    ul.layers li { display:flex; justify-content:space-between; padding: 2px 0; }
    svg { display:block; margin: 8px auto; border:1px solid #222; background:#000; }
    #errbar { position: fixed; top: 0; left: 0; right: 0; background: #7f1d1d; color: #fff; padding: 6px 10px; display:none; z-index: 9999; }
  </style>
</head>
<body>
  <div id="errbar" class="mono"></div>
  <div id="root"></div>

  <script>
    const errbar = document.getElementById('errbar');
    window.addEventListener('error', (e) => {
      errbar.style.display = 'block';
      errbar.textContent = 'Runtime error: ' + (e.message || e.error);
      console.error(e.error || e.message, e);
    });
    window.addEventListener('unhandledrejection', (e) => {
      errbar.style.display = 'block';
      errbar.textContent = 'Unhandled promise rejection: ' + (e.reason && e.reason.message ? e.reason.message : e.reason);
      console.error(e.reason);
    });
  </script>

  <script type="text/babel" data-presets="react">
    const { useEffect, useMemo, useRef, useState } = React;

    // ===== Webdis config =====
    const WEBDIS_BASE = "http://192.168.30.114:7379"; // adjust if needed
    const PHASE_KEYS = ["Phase1", "Phase2", "Phase3", "Phase4"];
    const PHASE_MAP  = { Phase1: 490, Phase2: 365, Phase3: 244, Phase4: 182 }; // highest active wins

    // ===== Helpers =====
    function isTruthy(v) {
      if (v == null) return false;
      const s = String(v).trim().toLowerCase();
      return s === "true" || s === "1" || s === "yes" || s === "on";
    }

    // Webdis MGET and fallback GET
    async function webdisMget(keys) {
      try {
        const url = `${WEBDIS_BASE}/MGET/${keys.map(encodeURIComponent).join("/")}.json`;
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) return [];
        const data = await res.json();
        if (data && Array.isArray(data.MGET)) return data.MGET;
        return [];
      } catch {
        return [];
      }
    }
    async function webdisGet(key) {
      try {
        const res = await fetch(`${WEBDIS_BASE}/GET/${encodeURIComponent(key)}.json`, { cache: "no-store" });
        // Try JSON shape
        try {
          const data = await res.json();
          if (data && data.GET !== undefined) {
            const g = data.GET;
            if (Array.isArray(g) && g.length) return String(g[0]).trim();
            if (g && typeof g === "object" && "value" in g) return String(g.value).trim();
          }
        } catch { /* fall through */ }
        // Fallback text
        const txt = await res.text();
        return txt ? String(txt).trim() : null;
      } catch {
        return null;
      }
    }
    async function webdisSet(key, value) {
      try {
        await fetch(`${WEBDIS_BASE}/SET/${encodeURIComponent(key)}/${encodeURIComponent(value)}.json`, { cache: "no-store" });
      } catch {}
    }

    // ===== Physics model =====
    function createOrbitState() {
      return { r: 145, v: 1.0, theta: 0, mu: 1.0, Cd: 2.2, A: 1.0, m: 1.0 };
    }
    function atmosphericDensity(r) {
      const h = Math.max(0, r - 40);
      if (h > 100) return 0.0001 * Math.exp(-(h - 100) / 50);
      if (h > 60)  return 0.001  * Math.exp(-(h - 60) / 20);
      return 0.01 * Math.exp(-(h - 40) / 5);
    }
    function stepOrbit(state, dt, velocityBoost) {
      const rho = atmosphericDensity(state.r);
      const dragAccel = 0.5 * state.Cd * (state.A / state.m) * rho * state.v * state.v * velocityBoost;
      const gravityAccel = state.mu / (state.r * state.r);
      const inwardAccel = dragAccel + gravityAccel;

      // tangential
      state.v += (gravityAccel - dragAccel) * dt;
      if (state.v > 10) state.v = 10;
      if (state.v < 0.1) state.v = 0.1;

      // radial
      state.r -= inwardAccel * dt * state.v * 0.5;
      if (state.r < 40) state.r = 40;

      // angular
      state.theta += (state.v / state.r) * dt;
      return state;
    }

    function App() {
      // State (no sliders; all options from Webdis)
      const [orbit, setOrbit] = useState(createOrbitState());
      const [fallFactor, setFallFactor] = useState(PHASE_MAP.Phase4); // default to Phase4 if none set
      const [webdisUp, setWebdisUp] = useState(null);

      // sent flags for layer keys
      const sentLayerFlagsRef = useRef({});

      // Layers / boundaries
      const layers = useMemo(() => ([
        { name: "Cloud Deck", key: "CloudDeck", r: 140, color: "#facc15" },
        { name: "Stratosheath", key: "Stratosheath", r: 100, color: "#f97316" },
        { name: "Red Zone", key: "RedZone", r: 60, color: "#dc2626" },
      ]), []);
      const boundaries = useMemo(() =>
        ([ ...layers.map(l => ({ name: l.name, key: l.key, r: l.r })), { name:"Crushdepth", key:"Crushdepth", r:40 } ]
          .sort((a,b) => b.r - a.r)), [layers]);

      // Animation loop: true seconds using RAF; no sim multiplier exposed
      const rafRef = useRef(null);
      const lastRef = useRef(null);
      useEffect(() => {
        function frame(ts) {
          if (lastRef.current == null) lastRef.current = ts;
          const dt = (ts - lastRef.current) / 1000; // real seconds
          lastRef.current = ts;
          setOrbit(prev => stepOrbit({ ...prev, mu: fallFactor }, dt, fallFactor));
          rafRef.current = requestAnimationFrame(frame);
        }
        rafRef.current = requestAnimationFrame(frame);
        return () => cancelAnimationFrame(rafRef.current);
      }, [fallFactor]);

      // Current layer & next target
      const currentLayer = useMemo(() => {
        const found = layers.find(l => orbit.r > l.r);
        return found ? found.name : layers[layers.length - 1].name;
      }, [layers, orbit.r]);

      const nextTarget = useMemo(() => {
        for (let i = 0; i < boundaries.length; i++) {
          if (orbit.r > boundaries[i].r) {
            for (let j = i; j < boundaries.length; j++) {
              if (boundaries[j].r < orbit.r) return boundaries[j];
            }
          }
        }
        if (orbit.r > 40) return { name: "Crushdepth", key: "Crushdepth", r: 40 };
        return null;
      }, [boundaries, orbit.r]);

      // Future path (ship-fixed, core-centered)
      const fullPath = useMemo(() => {
        const shipX = 250, shipY = 100;
        const pts = [];
        const r0 = orbit.r, th0 = orbit.theta;
        const shipPos = { x: r0 * Math.cos(th0), y: r0 * Math.sin(th0) };
        const T  = { x: -Math.sin(th0), y:  Math.cos(th0) };
        const In = { x: -Math.cos(th0), y: -Math.sin(th0) };

        let s = { ...orbit, mu: fallFactor };
        let lastTheta = s.theta, rotations = 0, desired = 6, steps = 0, MAX = 200000;

        while (s.r > 40 && rotations < desired && steps++ < MAX) {
          s = stepOrbit({ ...s }, 0.03, fallFactor);
          if (s.theta < lastTheta) rotations++;
          lastTheta = s.theta;

          const p = { x: s.r * Math.cos(s.theta), y: s.r * Math.sin(s.theta) };
          const rel = { x: p.x - shipPos.x, y: p.y - shipPos.y };
          const xh  = rel.x * T.x + rel.y * T.y;
          const yh  = rel.x * In.x + rel.y * In.y;
          pts.push(`${shipX + xh},${shipY + yh}`);
        }
        return `M 250,100 ${pts.map(p => `L ${p}`).join(" ")}`;
      }, [orbit, fallFactor]);

      // ETA (seconds) — real (no sim factor shown)
      const nextEtaSeconds = useMemo(() => {
        if (!nextTarget) return null;
        let s = { ...orbit, mu: fallFactor };
        let t = 0, dt = 0.05, steps = 0, MAX = 200000;
        while (s.r > nextTarget.r && steps++ < MAX) {
          s = stepOrbit({ ...s }, dt, fallFactor);
          t += dt;
          if (s.r <= 40) break;
        }
        return steps >= MAX ? null : t;
      }, [orbit, fallFactor, nextTarget]);

      // All boundaries (list) with each ETA (seconds)
      const layerETAs = useMemo(() => {
        return boundaries.map(b => {
          if (orbit.r <= b.r) return { ...b, status: "Threshold Reached", eta: null };
          let s = { ...orbit, mu: fallFactor };
          let t = 0, dt = 0.05, steps = 0, MAX = 200000;
          while (s.r > b.r && steps++ < MAX) {
            s = stepOrbit({ ...s }, dt, fallFactor);
            t += dt;
            if (s.r <= 40) break;
          }
          if (steps >= MAX) return { ...b, status: "—", eta: null };
          return { ...b, status: "ETA", eta: t };
        });
      }, [boundaries, orbit, fallFactor]);

      // Poll phases from Webdis (highest active wins)
      useEffect(() => {
        let stop = false;
        async function poll() {
          try {
            let vals = await webdisMget(PHASE_KEYS);
            if (!vals.length) {
              // Fallback GET per key
              const arr = await Promise.all(PHASE_KEYS.map(async k => [k, await webdisGet(k)]));
              vals = arr.map(([, v]) => v);
            }
            const active = PHASE_KEYS.filter((k, i) => isTruthy(vals[i]));
            if (active.length === 0) {
              setFallFactor(PHASE_MAP.Phase4);
            } else {
              const best = active.reduce((acc, k) => (PHASE_MAP[k] > PHASE_MAP[acc] ? k : acc), active[0]);
              setFallFactor(PHASE_MAP[best]);
            }
            setWebdisUp(true);
          } catch {
            setWebdisUp(false);
          } finally {
            if (!stop) setTimeout(poll, 1000);
          }
        }
        poll();
        return () => { stop = true; };
      }, []);

      // Emit layer flags (once) to Webdis
      useEffect(() => {
        boundaries.forEach(b => {
          if (orbit.r <= b.r && !sentLayerFlagsRef.current[b.key]) {
            sentLayerFlagsRef.current[b.key] = true;
            webdisSet(b.key, "true");
          }
        });
      }, [boundaries, orbit.r]);

      // Draw
      const planetCY = 100 + orbit.r;
      const rho = atmosphericDensity(orbit.r);
      const drag = 0.5 * orbit.Cd * (orbit.A / orbit.m) * rho * orbit.v * orbit.v * fallFactor;
      const g = fallFactor / (orbit.r * orbit.r);
      const inward = drag + g;
      const vx = 20 * orbit.v;
      const vy = 300 * inward;

      const mono = { fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace' };

      return (
        <div className="mono" style={{ display: "grid", placeItems: "center", minHeight: "100vh", background: "#000", color: "#fff" }}>
          {/* World (kept for situational awareness) */}
          <svg width="500" height="500" viewBox="0 0 500 500">
            <g>
              <circle cx="250" cy={planetCY} r="40" fill="#1e3a8a" />
              {layers.map((l, i) => (
                <circle key={i} cx="250" cy={planetCY} r={l.r} fill="none" stroke={l.color} strokeWidth="2" strokeOpacity="0.3" />
              ))}
              <path d={fullPath} fill="none" stroke="#00ffff" strokeWidth="1" strokeDasharray="3,3" strokeOpacity="0.6" />
            </g>
            {/* Ship & HUD vectors */}
            <circle cx="250" cy="100" r="6" fill="#22c55e" />
            <line x1="250" y1="100" x2={250 + vx} y2="100" stroke="#60a5fa" strokeWidth="2" />
            <line x1="250" y1="100" x2="250" y2={100 + vy} stroke="#f87171" strokeWidth="2" />
          </svg>

          {/* Minimal Readout Panel */}
          <div className="panel mono">
            <div className="row"><span className="label">Planet Name: </span><span className="value">Unknown</span></div>
            <div className="row"><span className="label">Planet Type: </span><span className="value">Unexplored Gas Giant.</span></div>
            <div className="row"><span className="label">Current Layer: </span><span className="value">{currentLayer}</span></div>

            <div className="title">Layer Crossings</div>
            <ul className="layers">
              {layerETAs.map((b, idx) => (
                <li key={idx}>
                  <span>{b.name}</span>
                  {b.status === "Threshold Reached"
                    ? <span>Threshold Reached</span>
                    : b.status === "—"
                      ? <span>—</span>
                      : <span>{b.eta.toFixed(1)}s</span>}
                </li>
              ))}
            </ul>

            <div className="row" style={{ marginTop: 8 }}>
              <span className="label">Next ETA (seconds): </span>
              <span className="value">{nextEtaSeconds == null ? "—" : nextEtaSeconds.toFixed(1)}</span>
            </div>

            <div className="row" style={{ marginTop: 6, opacity: 0.7, fontSize: 12 }}>
              Webdis: {webdisUp == null ? "…" : webdisUp ? "OK" : "Error"} | Fall Factor: {fallFactor}
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
