<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Orbit Decay UI â€” Webdis Phases (MGET + JSONP fixed)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    html, body { margin: 0; height: 100%; background: #000; }
    button { background:#111; color:#fff; border:1px solid #333; border-radius:6px; padding:4px 10px; cursor:pointer; }
    button:hover { border-color:#555; }
    input[type="range"] { accent-color:#0ea5e9; }
    #errbar { position: fixed; top: 0; left: 0; right: 0; background: #7f1d1d; color: #fff; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; padding: 6px 10px; display:none; z-index: 9999; }
  </style>
</head>
<body>
  <div id="errbar"></div>
  <div id="root"></div>

  <script>
    const errbar = document.getElementById('errbar');
    window.addEventListener('error', (e) => {
      errbar.style.display = 'block';
      errbar.textContent = 'Runtime error: ' + (e.message || e.error);
      console.error(e.error || e.message, e);
    });
    window.addEventListener('unhandledrejection', (e) => {
      errbar.style.display = 'block';
      errbar.textContent = 'Unhandled promise rejection: ' + (e.reason && e.reason.message ? e.reason.message : e.reason);
      console.error(e.reason);
    });
  </script>

  <script type="text/babel" data-presets="react">
    const { useEffect, useMemo, useRef, useState } = React;

    // ===== Webdis config =====
    const WEBDIS_BASE = "http://192.168.30.114:7379";
    const PHASE_KEYS = ["Phase1", "Phase2", "Phase3", "Phase4"];
    const PHASE_MAP  = { Phase1: 490, Phase2: 365, Phase3: 244, Phase4: 182 };

    function createOrbitState() {
      return { r: 145, v: 1.0, theta: 0, mu: 1.0, Cd: 2.2, A: 1.0, m: 1.0 };
    }

    function atmosphericDensity(r) {
      const h = Math.max(0, r - 40);
      if (h > 100) return 0.0001 * Math.exp(-(h - 100) / 50);
      if (h > 60)  return 0.001  * Math.exp(-(h - 60) / 20);
      return 0.01 * Math.exp(-(h - 40) / 5);
    }

    function stepOrbit(state, dt, velocityBoost) {
      const rho = atmosphericDensity(state.r);
      const dragAccel = 0.5 * state.Cd * (state.A / state.m) * rho * state.v * state.v * velocityBoost;
      const gravityAccel = state.mu / (state.r * state.r);
      const inwardAccel = dragAccel + gravityAccel;

      state.v += (gravityAccel - dragAccel) * dt;
      if (state.v > 10) state.v = 10;
      if (state.v < 0.1) state.v = 0.1;

      state.r -= inwardAccel * dt * state.v * 0.5;
      if (state.r < 40) state.r = 40;

      const angularRate = state.v / state.r;
      state.theta += angularRate * dt;
      return state;
    }

    // Robust truthy check
    function isTruthy(v) {
      if (v == null) return false;
      const s = String(v).trim().toLowerCase();
      return s === "true" || s === "1" || s === "yes" || s === "on";
    }

    // ===== JSONP + MGET helpers (handles CORS or JSONP) =====
    function jsonp(url, timeoutMs = 3000) {
      return new Promise((resolve, reject) => {
        const cb = "__wd_cb_" + Math.random().toString(36).slice(2);
        const s = document.createElement('script');
        const t = setTimeout(() => { cleanup(); reject(new Error("JSONP timeout: " + url)); }, timeoutMs);
        function cleanup(){ clearTimeout(t); delete window[cb]; if (s.parentNode) s.parentNode.removeChild(s); }
        window[cb] = (payload) => { cleanup(); resolve(payload); };
        s.src = url + (url.includes('?') ? '&' : '?') + "callback=" + cb;
        s.onerror = () => { cleanup(); reject(new Error("JSONP load error: " + url)); };
        document.head.appendChild(s);
      });
    }

    function parseWebdisMGetPayload(payload) {
      if (!payload) return null;
      let arr = payload.MGET || payload.mget;
      if (!arr) return null;
      if (Array.isArray(arr)) return arr.map(v => v == null ? null : String(v).trim());
      if (typeof arr === 'object' && Array.isArray(arr.values)) return arr.values.map(v => v == null ? null : String(v).trim());
      return null;
    }

    async function webdisMGet(keys) {
      const path = `${WEBDIS_BASE}/MGET/` + keys.map(k => encodeURIComponent(k)).join('/') + `.json`;
      try {
        const res = await fetch(path, { cache: 'no-store', mode: 'cors' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        const arr = parseWebdisMGetPayload(data);
        if (arr) return arr;
      } catch (_) { /* try JSONP */ }
      try {
        const jp = await jsonp(`${WEBDIS_BASE}/MGET/` + keys.map(k => encodeURIComponent(k)).join('/') + `.jsonp`);
        const arr = parseWebdisMGetPayload(jp);
        return arr || keys.map(() => null);
      } catch (_) {
        return keys.map(() => null);
      }
    }

    async function webdisSet(key, value) {
      try {
        const httpUrl = `${WEBDIS_BASE}/SET/${encodeURIComponent(key)}/${encodeURIComponent(value)}.json`;
        await fetch(httpUrl, { cache: 'no-store', mode: 'cors' });
      } catch (_) {
        // JSONP fallback
        try { await jsonp(`${WEBDIS_BASE}/SET/${encodeURIComponent(key)}/${encodeURIComponent(value)}.jsonp`); } catch {}
      }
    }

    function App() {
      const [orbit, setOrbit] = useState(createOrbitState());
      const [fallFactor, setFallFactor] = useState(PHASE_MAP["Phase4"]); // default lowest
      const [simRate, setSimRate] = useState(1);
      const [speedSetpoint, setSpeedSetpoint] = useState(1.0);
      const [view, setView] = useState(1);
      const [webdisOk, setWebdisOk] = useState(null);
      const [activePhase, setActivePhase] = useState("Phase4");
      const [phaseReads, setPhaseReads] = useState({ Phase1: null, Phase2: null, Phase3: null, Phase4: null });

      const [webhookUrl, setWebhookUrl] = useState("");
      const [webhookEnabled, setWebhookEnabled] = useState(false);
      const lastTriggerKeyRef = useRef("");
      const sentLayerFlagsRef = useRef({});

      const layers = useMemo(
        () => [
          { name: "Cloud Deck", key: "CloudDeck", r: 140, color: "#facc15" },
          { name: "Stratosheath", key: "Stratosheath", r: 100, color: "#f97316" },
          { name: "Red Zone", key: "RedZone", r: 60, color: "#dc2626" },
        ],
        []
      );

      const boundaries = useMemo(
        () => [...layers.map((l) => ({ name: l.name, key: l.key, r: l.r })), { name: "Crushdepth", key: "Crushdepth", r: 40 }].sort((a, b) => b.r - a.r),
        [layers]
      );

      // ===== Ticker =====
      useEffect(() => {
        const id = setInterval(() => {
          setOrbit(prev => stepOrbit({ ...prev, mu: fallFactor }, 0.03 * simRate, fallFactor));
        }, 30);
        return () => clearInterval(id);
      }, [fallFactor, simRate]);

      // ===== Camera / View =====
      const shipBaseX = 250;
      const shipBaseY = 100;
      let shipY = shipBaseY, scale = 1, translateY = 0;
      if (view === 2) { shipY = 250; translateY = shipY - shipBaseY; scale = 3; }
      else if (view === 3) { shipY = 250; translateY = shipY - shipBaseY; scale = 1; }

      const cameraTransform = useMemo(() => {
        const base = `translate(0,${translateY})`;
        return (scale !== 1)
          ? `${base} translate(${shipBaseX},${shipBaseY}) scale(${scale}) translate(${-shipBaseX},${-shipBaseY})`
          : base;
      }, [translateY, scale]);

      const currentLayer = useMemo(() => {
        const found = layers.find((l) => orbit.r > l.r);
        return found ? found.name : layers[layers.length - 1].name;
      }, [layers, orbit.r]);

      const nextTarget = useMemo(() => {
        for (let i = 0; i < boundaries.length; i++) {
          if (orbit.r > boundaries[i].r) {
            for (let j = i; j < boundaries.length; j++) {
              if (boundaries[j].r < orbit.r) return boundaries[j];
            }
          }
        }
        if (orbit.r > 40) return { name: "Crushdepth", key: "Crushdepth", r: 40 };
        return null;
      }, [boundaries, orbit.r]);

      const fullPath = useMemo(() => {
        const pts = [];
        const r0 = orbit.r;
        const th0 = orbit.theta;
        const shipPos = { x: r0 * Math.cos(th0), y: r0 * Math.sin(th0) };
        const T = { x: -Math.sin(th0), y: Math.cos(th0) };
        const In = { x: -Math.cos(th0), y: -Math.sin(th0) };

        let s = { ...orbit, mu: fallFactor };
        let lastTheta = s.theta, rotations = 0;
        const desiredRotations = 6;
        let maxSteps = 200000;

        while (s.r > 40 && rotations < desiredRotations && maxSteps-- > 0) {
          s = stepOrbit({ ...s }, 0.03 * simRate, fallFactor);
          if (s.theta < lastTheta) rotations++;
          lastTheta = s.theta;

          const p = { x: s.r * Math.cos(s.theta), y: s.r * Math.sin(s.theta) };
          const rel = { x: p.x - shipPos.x, y: p.y - shipPos.y };
          const xh = rel.x * T.x + rel.y * T.y;
          const yh = rel.x * In.x + rel.y * In.y;

          const px = shipBaseX + xh;
          const py = shipBaseY + yh;
          pts.push(`${px},${py}`);
        }
        return `M ${shipBaseX},${shipBaseY} ${pts.map((p) => `L ${p}`).join(" ")}`;
      }, [orbit, fallFactor, simRate]);

      // ===== Readouts =====
      const rho = atmosphericDensity(orbit.r);
      const dragAccel = 0.5 * (orbit.Cd * (orbit.A / orbit.m)) * rho * orbit.v * orbit.v * fallFactor;
      const gravityAccel = fallFactor / (orbit.r * orbit.r);
      const inwardAccel = dragAccel + gravityAccel;
      const vx = 20 * orbit.v;
      const vy = 300 * inwardAccel;

      const etaSimSeconds = useMemo(() => {
        if (!nextTarget) return null;
        let s = { ...orbit, mu: fallFactor };
        let t = 0, dt = 0.05, steps = 0, MAX = 200000;
        while (s.r > nextTarget.r && steps++ < MAX) {
          s = stepOrbit({ ...s }, dt, fallFactor);
          t += dt;
          if (s.r <= 40) break;
        }
        return steps >= MAX ? null : t;
      }, [orbit, fallFactor, nextTarget]);

      const etaRealSeconds = useMemo(() => etaSimSeconds == null ? null : (etaSimSeconds / Math.max(simRate, 0.0001)), [etaSimSeconds, simRate]);

      const orbitalPeriodSimSeconds = useMemo(() => {
        const angRate = orbit.v / Math.max(orbit.r, 1e-6);
        return angRate <= 0 ? null : (2 * Math.PI) / angRate;
      }, [orbit.v, orbit.r]);

      const orbitalPeriodRealSeconds = useMemo(
        () => orbitalPeriodSimSeconds == null ? null : (orbitalPeriodSimSeconds / Math.max(simRate, 0.0001)),
        [orbitalPeriodSimSeconds, simRate]
      );

      const allBoundaries = useMemo(
        () => [...layers.map((l) => ({ name: l.name, key: l.key, r: l.r })), { name: "Crushdepth", key: "Crushdepth", r: 40 }].sort((a, b) => b.r - a.r),
        [layers]
      );

      const layerETAs = useMemo(() => {
        return allBoundaries.map((b) => {
          if (orbit.r <= b.r) return { ...b, status: "Threshold Reached", etaSim: null, etaReal: null };
          let s = { ...orbit, mu: fallFactor };
          let t = 0, dt = 0.05, steps = 0, MAX = 200000;
          while (s.r > b.r && steps++ < MAX) {
            s = stepOrbit({ ...s }, dt, fallFactor);
            t += dt;
            if (s.r <= 40) break;
          }
          if (steps >= MAX) return { ...b, status: "â€”", etaSim: null, etaReal: null };
          const sim = t;
          const real = sim / Math.max(simRate, 0.0001);
          return { ...b, status: "ETA", etaSim: sim, etaReal: real };
        });
      }, [allBoundaries, orbit, fallFactor, simRate]);

      // Optional ping so we can show a quick OK/Error
      useEffect(() => {
        (async () => {
          try {
            const res = await fetch(`${WEBDIS_BASE}/PING.json`, { cache: 'no-store', mode: 'cors' });
            setWebdisOk(res.ok);
          } catch { setWebdisOk(false); }
        })();
      }, []);

      // Poll phases via MGET and apply highest mapped factor among truthy
      useEffect(() => {
        let stop = false;
        async function poll() {
          try {
            const vals = await webdisMGet(PHASE_KEYS);
            const reads = {};
            PHASE_KEYS.forEach((k, i) => { reads[k] = vals[i]; });
            setPhaseReads(reads);

            const active = PHASE_KEYS.filter((k, i) => isTruthy(vals[i]));
            if (active.length === 0) {
              setActivePhase("Phase4");
              setFallFactor(PHASE_MAP["Phase4"]);
            } else {
              const best = active.reduce((acc, k) => (PHASE_MAP[k] > PHASE_MAP[acc] ? k : acc), active[0]);
              setActivePhase(best);
              setFallFactor(PHASE_MAP[best]);
            }
            setWebdisOk(true);
          } catch (e) {
            setWebdisOk(false);
          } finally {
            if (!stop) setTimeout(poll, 1000);
          }
        }
        poll();
        return () => { stop = true; };
      }, []);

      // Emit layer-cross flags exactly once per key
      useEffect(() => {
        boundaries.forEach((b) => {
          if (orbit.r <= b.r && !sentLayerFlagsRef.current[b.key]) {
            sentLayerFlagsRef.current[b.key] = true;
            webdisSet(b.key, "true");
          }
        });
      }, [boundaries, orbit.r]);

      // Webhook on crossing
      useEffect(() => {
        if (!nextTarget) return;
        const key = `${nextTarget.name}:${nextTarget.r.toFixed(2)}`;
        if (lastTriggerKeyRef.current === key) return;
        if (orbit.r <= nextTarget.r) {
          if (webhookEnabled && webhookUrl) {
            try {
              fetch(webhookUrl, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  event: nextTarget.name === "Crushdepth" ? "crushdepth-reached" : "layer-transition",
                  target: nextTarget,
                  state: { r: orbit.r, v: orbit.v, theta: orbit.theta },
                  at: new Date().toISOString(),
                }),
              }).catch(() => {});
            } catch {}
          }
          lastTriggerKeyRef.current = key;
        }
      }, [orbit.r, nextTarget, webhookEnabled, webhookUrl]);

      const mono = { fontFamily:'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace' };
      const planetCenterY = 100 + orbit.r;

      return (
        <div style={{ background: "#000", color: "#fff", height: "100vh", display: "grid", placeItems: "center" }}>
          <div style={{ display: "flex", flexDirection: "column", alignItems: "center", background: "#000", ...mono }}>
            {/* Views */}
            <div style={{ marginBottom: 8, display: "flex", gap: 8 }}>
              <button onClick={() => setView(1)}>View 1</button>
              <button onClick={() => setView(2)}>View 2</button>
              <button onClick={() => setView(3)}>View 3</button>
            </div>

            {/* World */}
            <svg width="500" height="500" viewBox="0 0 500 500" style={{ border: "1px solid #222", background: "#000" }}>
              <g transform={cameraTransform}>
                <circle cx="250" cy={planetCenterY} r="40" fill="#1e3a8a" />
                {layers.map((l, i) => (
                  <circle key={i} cx="250" cy={planetCenterY} r={l.r} fill="none" stroke={l.color} strokeWidth="2" strokeOpacity="0.3" />
                ))}
                <path d={fullPath} fill="none" stroke="#00ffff" strokeWidth="1" strokeDasharray="3,3" strokeOpacity="0.6" />
              </g>

              {/* Ship + vectors */}
              <circle cx="250" cy="100" r="6" fill="#22c55e" />
              <line x1="250" y1="100" x2={250 + 20*orbit.v} y2="100" stroke="#60a5fa" strokeWidth="2" />
              <polygon points={`${250 + 20*orbit.v},${100} ${250 + 20*orbit.v - 6},${100 - 4} ${250 + 20*orbit.v - 6},${100 + 4}`} fill="#60a5fa" />
              <line x1="250" y1="100" x2="250" y2={100 + 300*(dragAccel+gravityAccel)} stroke="#f87171" strokeWidth="2" />
              <polygon points={`${250},${100 + 300*(dragAccel+gravityAccel)} ${250 - 4},${100 + 300*(dragAccel+gravityAccel) - 6} ${250 + 4},${100 + 300*(dragAccel+gravityAccel) - 6}`} fill="#f87171" />
            </svg>

            {/* Readouts */}
            <div style={{ marginTop: 12, fontSize: 16, textAlign: "center", maxWidth: 560 }}>
              <div>Current Layer: <strong>{currentLayer}</strong></div>
              <div>Radius: <strong>{orbit.r.toFixed(1)}</strong> | Velocity: <strong>{orbit.v.toFixed(3)}</strong></div>
              <div>Fall Factor (Webdis): <strong>{fallFactor}</strong> <span style={{ opacity: 0.8 }}>({activePhase})</span>
                {" "} | Webdis: <strong>{webdisOk == null ? "â€¦" : webdisOk ? "OK" : "Error"}</strong>
              </div>
              <div style={{ opacity: 0.8, fontSize: 14, marginTop: 4 }}>
                Phase reads â€” P1:{String(phaseReads.Phase1)} | P2:{String(phaseReads.Phase2)} | P3:{String(phaseReads.Phase3)} | P4:{String(phaseReads.Phase4)}
              </div>

              <div style={{ marginTop: 6 }}>
                Orbital Period â€” sim: <strong>{orbitalPeriodSimSeconds == null ? "â€”" : orbitalPeriodSimSeconds.toFixed(1)}s</strong>
                {" "}| real @ {simRate.toFixed(1)}Ã—: <strong>{orbitalPeriodRealSeconds == null ? "â€”" : orbitalPeriodRealSeconds.toFixed(1)}s</strong>
              </div>

              <div style={{ marginTop: 6 }}>
                {nextTarget ? (
                  <>
                    Next: <strong>{nextTarget.name}</strong> @ r={nextTarget.r}
                    {" "}| ETA (sim): <strong>{etaSimSeconds == null ? "â€”" : etaSimSeconds.toFixed(1)}s</strong>
                    {" "}| ETA (real @ {simRate.toFixed(1)}Ã—): <strong>{etaRealSeconds == null ? "â€”" : Math.max(0, etaRealSeconds).toFixed(1)}s</strong>
                  </>
                ) : (
                  <span>At crushdepth</span>
                )}
              </div>

              <div style={{ marginTop: 8, textAlign: "left", marginInline: "auto", width: 420 }}>
                <div style={{ opacity: 0.9, marginBottom: 4 }}>Layer Crossings:</div>
                <ul style={{ listStyle: "none", padding: 0, margin: 0 }}>
                  {layerETAs.map((b, idx) => (
                    <li key={idx} style={{ display: "flex", justifyContent: "space-between", padding: "2px 0" }}>
                      <span>{b.name}</span>
                      {b.status === "Threshold Reached" ? (
                        <span>Threshold Reached</span>
                      ) : b.status === "â€”" ? (
                        <span>â€”</span>
                      ) : (
                        <span>sim: {b.etaSim.toFixed(1)}s | real: {b.etaReal.toFixed(1)}s</span>
                      )}
                    </li>
                  ))}
                </ul>
              </div>
            </div>

            {/* Controls */}
            <div style={{ marginTop: 12, display: "grid", gap: 10 }}>
              <div style={{ display: "flex", gap: 12, alignItems: "center" }}>
                <label htmlFor="simRate" style={{ width: 110 }}>Sim Rate</label>
                <input id="simRate" type="range" min="0.1" max="10" step="0.1" value={simRate}
                       onChange={(e) => setSimRate(parseFloat(e.target.value))}
                       style={{ width: 280 }} />
                <span style={{ minWidth: 60, textAlign: "right" }}>{simRate.toFixed(1)}Ã—</span>
              </div>

              <div style={{ display: "flex", gap: 12, alignItems: "center" }}>
                <label htmlFor="speedSetpoint" style={{ width: 110 }}>Orbital Speed</label>
                <input id="speedSetpoint" type="range" min="0.1" max="10" step="0.1" value={speedSetpoint}
                       onChange={(e) => setSpeedSetpoint(parseFloat(e.target.value))}
                       style={{ width: 280 }} />
                <button onClick={() => setOrbit((prev) => ({ ...prev, v: speedSetpoint }))}>Apply</button>
                <span style={{ minWidth: 60, textAlign: "right" }}>{speedSetpoint.toFixed(1)}</span>
              </div>

              {/* Webhook controls */}
              <div style={{ display: "flex", gap: 12, alignItems: "center" }}>
                <label htmlFor="webhookUrl" style={{ width: 110 }}>Webhook URL</label>
                <input id="webhookUrl" type="text" placeholder="https://example.com/hook"
                       value={webhookUrl} onChange={(e) => setWebhookUrl(e.target.value)}
                       style={{ width: 280, padding: 4, background: '#0b0b0b', border: '1px solid #333', color: '#fff', borderRadius: 6 }} />
                <label style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                  <input type="checkbox" checked={webhookEnabled}
                         onChange={(e) => setWebhookEnabled(e.target.checked)} /> Enable
                </label>
              </div>
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
