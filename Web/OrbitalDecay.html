// Layer edges (you already have these constants)
const CORE_R = 38;
const RED_ZONE_R = 63;   // (was 60, +5%)
const STRATO_R = 100;
const CLOUD_R  = 140;

// Returns a smoothly increasing density as we go inward (smaller r)
// with sharper growth in the Red Zone and a final spike near CORE_R.
function atmosphericDensity(r) {
  const h = Math.max(0, r - CORE_R); // “altitude” above crushdepth

  // Piecewise shapes tuned for “steeper inside Red Zone”
  if (r > CLOUD_R) {
    // very thin
    return 0.00005 * Math.exp(-(h - (CLOUD_R - CORE_R)) / 70);
  } else if (r > STRATO_R) {
    // Stratosheath: moderate
    return 0.0005 * Math.exp(-(h - (STRATO_R - CORE_R)) / 35);
  } else if (r > RED_ZONE_R) {
    // Upper transition toward Red Zone
    return 0.002 * Math.exp(-(h - (RED_ZONE_R - CORE_R)) / 18);
  } else {
    // RED ZONE: steep ramp + final spike near CORE_R
    const base = 0.01 * Math.exp(-(h) / 7);      // sharp growth
    const spike = 0.02 * Math.exp(-h / 3);       // extra near crushdepth
    return base + spike;
  }
}

// Optional extra multiplicative factor for drag that emphasizes layers.
// Keeps the old “special dropoff” feel without breaking geometry.
function dragMultiplier(r) {
  if (r <= CORE_R + 8) return 4.0;       // close to crushdepth: strongest
  if (r <= RED_ZONE_R) return 3.2;       // Red Zone: strong
  if (r <= STRATO_R)  return 1.6;        // Stratosheath: moderate
  return 1.0;                             // Above Cloud Deck: light
}

function stepOrbit(state, dt, velocityBoost) {
  const rho = atmosphericDensity(state.r);
  const layerBoost = dragMultiplier(state.r);  // NEW
  const dragAccel = 0.5 * state.Cd * (state.A / state.m) * rho * state.v * state.v
                    * velocityBoost * layerBoost; // emphasize per-layer

  const gravityAccel = state.mu / (state.r * state.r);
  const inwardAccel = dragAccel + gravityAccel;

  // tangential evolution
  state.v += (gravityAccel - dragAccel) * dt;
  if (state.v > 10) state.v = 10;
  if (state.v < 0.1) state.v = 0.1;

  // radial decay (inward)
  state.r -= inwardAccel * dt * state.v * 0.5;
  if (state.r < CORE_R) state.r = CORE_R;

  // angular motion
  state.theta += (state.v / state.r) * dt;
  return state;
}
