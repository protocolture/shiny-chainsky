<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Orbit HUD — Forecast-Driven Crossings (CRT Red/Amber/Blue)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- React + Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- CRT terminal font -->
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

  <style>
    :root {
      --crt-green:  #5fff85;
      --crt-dim:    #2a4;
      --crt-red:    #ff3b3b;   /* Red Zone ring */
      --crt-amber:  #ffbf3b;   /* Core */
      --crt-blue:   #4fc3ff;   /* Spiral */
      --bg:         #000000;
    }
    html, body { margin: 0; height: 100%; background: var(--bg); }
    body { color: var(--crt-green); font-family: 'VT323', ui-monospace, monospace; }

    .crt {
      position: relative;
      min-height: 100vh;
      display: grid;
      place-items: center;
      background: var(--bg);
      overflow: hidden;
    }
    .crt::before {
      content: "";
      position: absolute; inset: 0;
      background: repeating-linear-gradient(
        to bottom,
        rgba(95,255,133,0.06) 0px,
        rgba(95,255,133,0.06) 2px,
        rgba(0,0,0,0) 3px,
        rgba(0,0,0,0) 4px
      );
      pointer-events: none;
      mix-blend-mode: screen;
      opacity: 0.45;
    }
    .crt::after {
      content: "";
      position: absolute; inset: 0;
      background:
        radial-gradient(circle at 50% 50%, rgba(0,0,0,0) 60%, rgba(0,0,0,0.35) 85%),
        linear-gradient(to bottom, rgba(255,255,255,0.03), rgba(0,0,0,0) 40%, rgba(255,255,255,0.02) 60%, rgba(0,0,0,0.1));
      pointer-events: none;
      mix-blend-mode: multiply;
    }
    .flicker {
      animation: flicker 2.5s infinite steps(60);
      text-shadow: 0 0 6px rgba(95,255,133,0.6), 0 0 24px rgba(95,255,133,0.25);
    }
    @keyframes flicker {
      0%, 19%, 21%, 23%, 80%, 100% { opacity: 1; }
      20%, 22% { opacity: 0.95; }
      81% { opacity: 0.98; }
    }

    .wrap {
      width: 100%;
      max-width: 1400px;
      display: flex;
      gap: 16px;
      align-items: flex-start;
      padding: 14px;
    }

    .panel {
      flex: 0 0 390px;
      border: 1px solid var(--crt-dim);
      background: rgba(0,0,0,0.75);
      padding: 12px 16px;
    }
    .title { font-size: 28px; margin-bottom: 10px; }
    .row { font-size: 22px; display: flex; gap: 6px; margin: 6px 0; }
    .label { opacity: 0.85; min-width: 170px; }
    .value { font-weight: 700; }
    ul.layers { list-style:none; padding:0; margin: 8px 0 0 0; }
    ul.layers li { display:flex; justify-content:space-between; padding: 3px 0; font-size: 20px; }

    .viewport {
      width: 703px;
      height: 703px;
      border: 1px solid var(--crt-dim);
      background: #000;
      box-shadow: 0 0 20px rgba(95,255,133,0.2) inset;
    }

    #errbar {
      position: fixed; top: 0; left: 0; right: 0;
      background: #083; color: #caffda; padding: 6px 10px;
      display:none; z-index: 9999; border-bottom: 1px solid var(--crt-dim);
      font-family: 'VT323', ui-monospace, monospace;
    }
  </style>
</head>
<body>
  <div id="errbar"></div>
  <div id="root" class="crt"></div>

  <script>
    const errbar = document.getElementById('errbar');
    window.addEventListener('error', (e) => {
      errbar.style.display = 'block';
      errbar.textContent = 'Runtime error: ' + (e.message || e.error);
      console.error(e.error || e.message, e);
    });
    window.addEventListener('unhandledrejection', (e) => {
      errbar.style.display = 'block';
      errbar.textContent = 'Unhandled promise rejection: ' + (e.reason && e.reason.message ? e.reason.message : e.reason);
      console.error(e.reason);
    });
  </script>

  <script type="text/babel" data-presets="react">
    const { useEffect, useMemo, useRef, useState } = React;

    // --- Config ---
    const WEBDIS_BASE = "http://192.168.30.114:7379";
    const CORE_R = 38;
    const RED_ZONE_R = 63;
    const STRATO_R = 100;
    const CLOUD_R = 140;

    const PHASE_KEYS = ["Phase1", "Phase2", "Phase3", "Phase4"];
    const PHASE_MAP  = { Phase1: 490, Phase2: 365, Phase3: 244, Phase4: 182 };

    // --- Helpers: Webdis ---
    function isTruthy(v) {
      if (v == null) return false;
      const s = String(v).trim().toLowerCase();
      return s === "true" || s === "1" || s === "yes" || s === "on";
    }
    async function webdisMget(keys) {
      try {
        const res = await fetch(`${WEBDIS_BASE}/MGET/${keys.map(encodeURIComponent).join("/")}.json`, { cache: "no-store" });
        if (!res.ok) return [];
        const data = await res.json();
        const g = data?.MGET;
        if (Array.isArray(g) && g.length === keys.length) return g.map(v => (v == null ? null : String(v)));
        if (Array.isArray(g)) return g.map(o => (o && typeof o === 'object' && 'value' in o) ? String(o.value) : null);
        return [];
      } catch { return []; }
    }
    async function webdisGet(key) {
      try {
        const res = await fetch(`${WEBDIS_BASE}/GET/${encodeURIComponent(key)}.json`, { cache: "no-store" });
        if (!res.ok) return null;
        const data = await res.json();
        const g = data?.GET;
        if (Array.isArray(g) && g.length) return String(g[0]);
        if (g && typeof g === 'object' && 'value' in g) return String(g.value);
      } catch {}
      return null;
    }
    async function webdisMset(kvObj) {
      try {
        const parts = [];
        for (const [k, v] of Object.entries(kvObj)) {
          parts.push(encodeURIComponent(k), encodeURIComponent(v));
        }
        await fetch(`${WEBDIS_BASE}/MSET/${parts.join("/")}.json`, { cache: "no-store" });
      } catch {}
    }

    // --- Physics (unchanged) ---
    function atmosphericDensity(r) {
      const h = Math.max(0, r - CORE_R);
      if (r > CLOUD_R) {
        return 0.00005 * Math.exp(-(h - (CLOUD_R - CORE_R)) / 70);
      } else if (r > STRATO_R) {
        return 0.0005 * Math.exp(-(h - (STRATO_R - CORE_R)) / 35);
      } else if (r > RED_ZONE_R) {
        return 0.002 * Math.exp(-(h - (RED_ZONE_R - CORE_R)) / 18);
      } else {
        const base = 0.01 * Math.exp(-h / 7);
        const spike = 0.02 * Math.exp(-h / 3);
        return base + spike;
      }
    }
    function dragMultiplier(r) {
      if (r <= CORE_R + 8) return 4.0;
      if (r <= RED_ZONE_R) return 3.2;
      if (r <= STRATO_R)  return 1.6;
      return 1.0;
    }




    function stepOrbit(state, dt, velocityBoost) {


      const rho = atmosphericDensity(state.r);


      const dragAccel = 0.5 * state.Cd * (state.A / state.m) * rho * state.v * state.v * velocityBoost;


      const gravityAccel = state.mu / (state.r * state.r);


      const inwardAccel = dragAccel + gravityAccel;





      state.v += (gravityAccel - dragAccel) * dt;


      if (state.v > 10) state.v = 10;


      if (state.v < 0.1) state.v = 0.1;





      state.r -= inwardAccel * dt * state.v * 0.5;


      if (state.r < CORE_R) state.r = CORE_R;





      state.theta += (state.v / state.r) * dt;


      return state;


    }

    // --- Forecast ETAs for crossings (stable + monotonic) ---
    function forecastLayerETAs(orbit, fallFactor, boundaries) {
      // Sim forward with fixed dt (sim seconds), find t at which r <= each boundary.r
      const s = { ...orbit, mu: fallFactor };
      const remaining = boundaries
        .filter(b => s.r > b.r)
        .map(b => ({ key: b.key, r: b.r, t: null }));

      if (remaining.length === 0) {
        // Already past all; return all with null ETA (reached)
        return Object.fromEntries(boundaries.map(b => [b.key, null]));
      }

      // Predict
      const dt = 0.05; // sim seconds per step
      const MAX_STEPS = 250000;
      let t = 0; let steps = 0;

      // Track first-hit times
      const hit = Object.fromEntries(remaining.map(x => [x.key, null]));

      while (steps++ < MAX_STEPS) {
        const prevR = s.r;
        stepOrbit(s, dt, fallFactor);
        t += dt;

        for (const b of remaining) {
          if (hit[b.key] == null && s.r <= b.r) {
            // linear interpolate crossing time within the step (optional)
            const alpha = Math.max(0, Math.min(1, (prevR - b.r) / Math.max(1e-6, prevR - s.r)));
            const tCross = t - dt * (1 - alpha);
            hit[b.key] = tCross;
          }
        }

        if (Object.values(hit).every(v => v != null) || s.r <= CORE_R) break;
      }

      // Build full map: boundaries already crossed ⇒ null ETA; others ⇒ hit[key] (seconds) or null if not found
      const out = {};
      for (const b of boundaries) {
        if (orbit.r <= b.r) out[b.key] = null; // already reached
        else out[b.key] = hit[b.key];          // seconds (may be null if not found)
      }
      return out;
    }

    function App() {
      const [orbit, setOrbit] = useState({ r:145, v:1, theta:0, mu:1, Cd:2.2, A:1, m:1 });
      const [fallFactor, setFallFactor] = useState(PHASE_MAP.Phase4);

      const orbitRef = useRef(orbit);
      useEffect(() => { orbitRef.current = orbit; }, [orbit]);

      const shipBaseX = 250;
      const shipBaseY = 100;

      const layers = useMemo(() => ([
        { name:"Cloud Deck",    key:"CloudDeck",     r:CLOUD_R,    color:"#5fff85" },
        { name:"Stratosheath",  key:"Stratosheath",  r:STRATO_R,   color:"#3fff73" },
        { name:"Red Zone",      key:"RedZone",       r:RED_ZONE_R, color:"var(--crt-red)" }
      ]), []);
      const boundaries = useMemo(() => ([ ...layers, { name:"Crushdepth", key:"Crushdepth", r:CORE_R } ]), [layers]);

      // Phase polling → choose highest active phase
      useEffect(() => {
        let stop = false;
        async function poll() {
          try {
            let vals = await webdisMget(PHASE_KEYS);
            if (!vals.length) vals = await Promise.all(PHASE_KEYS.map(k => webdisGet(k)));
            const active = PHASE_KEYS.filter((k,i)=>isTruthy(vals[i]));
            const chosen = active.length
              ? active.reduce((acc,k)=> (PHASE_MAP[k] > PHASE_MAP[acc] ? k : acc), active[0])
              : "Phase4";
            setFallFactor(PHASE_MAP[chosen]);
          } catch {}
          if (!stop) setTimeout(poll, 1000);
        }
        poll();
        return ()=>{stop=true};
      }, []);

      // RAF: integrate true seconds
      useEffect(() => {
        let raf, last;
        function frame(ts) {
          if (!last) last = ts;
          let dt = (ts - last) / 1000; last = ts;
          if (dt > 0.25) dt = 0.25;
          const next = stepOrbit({ ...orbitRef.current, mu: fallFactor }, dt, fallFactor);
          orbitRef.current = next;
          setOrbit(next);
          raf = requestAnimationFrame(frame);
        }
        raf = requestAnimationFrame(frame);
        return ()=> cancelAnimationFrame(raf);
      }, [fallFactor]);

      // Forecast-driven ETAs (monotonic) + latched Webdis updates
      const etaCacheRef = useRef({});   // key -> last best (monotonic non-increasing)
      const crossedRef  = useRef({      // key -> boolean (latched)
        CloudDeck:false, Stratosheath:false, RedZone:false, Crushdepth:false
      });
      const [layerETAs, setLayerETAs] = useState([]); // for UI

      useEffect(() => {
        let stop = false;
        async function tickForecast() {
          const s = orbitRef.current;
          const etaMap = forecastLayerETAs(s, fallFactor, boundaries);

          // Monotonic filter + build UI list
          const ui = boundaries.map(b => {
            const eta = etaMap[b.key]; // seconds or null (already crossed / not found)
            if (eta == null) {
              etaCacheRef.current[b.key] = null;
              return { ...b, status: "Threshold Reached", eta: null };
            }
            const prev = etaCacheRef.current[b.key];
            const best = (typeof prev === "number") ? Math.min(prev, eta) : eta;
            etaCacheRef.current[b.key] = best;
            return { ...b, status: "ETA", eta: best };
          });
          setLayerETAs(ui);

          // Decide which flags to set true (once) based on forecast
          // We consider "imminent" when ETA <= window, or already below radius.
          const WINDOW = 0.15; // seconds
          const toSet = {};
          boundaries.forEach(b => {
            const alreadyBelow = s.r <= b.r;
            const eta = etaMap[b.key];
            const imminent = (typeof eta === "number") && (eta <= WINDOW);
            if ((alreadyBelow || imminent) && !crossedRef.current[b.key]) {
              crossedRef.current[b.key] = true;
              toSet[b.key] = "true";
            }
          });
          if (Object.keys(toSet).length) {
            webdisMset(toSet);
          }

          if (!stop) setTimeout(tickForecast, 200); // 5 Hz is plenty for stability
        }
        tickForecast();
        return ()=>{stop=true};
      }, [fallFactor, boundaries]);

      // UI bits
      const currentLayer = useMemo(()=>{
        const found = layers.find(l=>orbit.r > l.r);
        return found ? found.name : layers[layers.length-1].name;
      }, [orbit.r, layers]);

      // Spiral preview (anchored at ship; small dt first steps to remove initial long segment)
      const fullPath = useMemo(() => {
        const pts = [];
        const r0 = orbit.r;
        const th0 = orbit.theta;
        const shipPos = { x: r0 * Math.cos(th0), y: r0 * Math.sin(th0) };
        const T = { x: -Math.sin(th0), y: Math.cos(th0) };
        const In = { x: -Math.cos(th0), y: -Math.sin(th0) };

        let s = { ...orbit, mu: fallFactor };
        let lastTheta = s.theta, rotations = 0, steps = 0;

        const dtSmall = 0.01;
        while (s.r > CORE_R && rotations < 6 && steps++ < 200000) {
          const dt = steps < 50 ? dtSmall : 0.03;
          s = stepOrbit({ ...s }, dt, fallFactor);
          if (s.theta < lastTheta) rotations++;
          lastTheta = s.theta;

          const p = { x: s.r * Math.cos(s.theta), y: s.r * Math.sin(s.theta) };
          const rel = { x: p.x - shipPos.x, y: p.y - shipPos.y };
          const xh = rel.x * T.x + rel.y * T.y;
          const yh = rel.x * In.x + rel.y * In.y;
          const px = shipBaseX + xh;
          const py = shipBaseY + yh;
          pts.push(`${px},${py}`);
        }
        if (pts.length === 0) return `M ${shipBaseX},${shipBaseY}`;
        return `M ${shipBaseX},${shipBaseY} L ${pts.join(" L ")}`;
      }, [orbit, fallFactor]);

      const planetCY = shipBaseY + orbit.r;
      const sceneScale = "translate(250,250) scale(1.25) translate(-250,-250)";

      return (
        <div className="wrap">
          <div className="panel flicker">
            <div className="title">ORBITAL STATUS — LINK: ACTIVE</div>
            <div className="row"><span className="label">Planet Name:</span><span className="value">Unknown</span></div>
            <div className="row"><span className="label">Planet Type:</span><span className="value">Unexplored Gas Giant.</span></div>
            <div className="row"><span className="label">Current Layer:</span><span className="value">{currentLayer}</span></div>
            <div className="row" style={{marginTop:8}}><span className="label">Layer Crossings:</span></div>
            <ul className="layers">
              {layerETAs.map((b,idx)=>(
                <li key={idx}>
                  <span>{b.name}</span>
                  {b.status==="Threshold Reached"
                    ? <span>Threshold Reached</span>
                    : (typeof b.eta === "number"
                        ? <span>ETA: {b.eta.toFixed(1)}s</span>
                        : <span>—</span>)}
                </li>
              ))}
            </ul>
          </div>

          <svg className="viewport" viewBox="0 0 500 500">
            <g transform={sceneScale}>
              {/* Core (amber) */}
              <circle cx="250" cy={planetCY} r={CORE_R} fill="var(--crt-amber)"/>
              {/* Atmosphere rings */}
              {layers.map((l,i)=>(
                <circle key={i} cx="250" cy={planetCY} r={l.r}
                  fill="none" stroke={l.color} strokeWidth="2" strokeOpacity="0.35"/>
              ))}
              {/* Spiral (CRT blue) */}
              <path d={fullPath} fill="none" stroke="var(--crt-blue)" strokeWidth="1.5"
                strokeDasharray="4,3" strokeOpacity="0.9"/>
              {/* Ship sprite */}
              <image href="ship.png" x="238" y="88" width="24" height="24"/>
            </g>
          </svg>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
